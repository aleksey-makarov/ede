<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Text.EDE</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Text-EDE.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">ed-e-0.1.0: Textual Templating Language</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Portability</th><td>non-portable (GHC extensions)</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Maintainer</th><td>Brendan Hay &lt;brendan.g.hay@gmail.com&gt;</td></tr><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Text.EDE</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">How to use this library
</a></li><li><a href="#g:2">Parsing and rendering
</a></li><li><a href="#g:3">Results and errors
</a></li><li><a href="#g:4">Convenience
</a><ul><li><a href="#g:5">Data.Aeson
</a></li><li><a href="#g:6">Data.Text.Lazy.Builder
</a></li></ul></li><li><a href="#g:7">Syntax
</a><ul><li><a href="#g:8">Comments
</a></li><li><a href="#g:9">Variables
</a></li><li><a href="#g:10">Conditionals
</a><ul><li><a href="#g:11">Boolean Logic
</a></li><li><a href="#g:12">Relational Logic
</a></li><li><a href="#g:13">Negation
</a></li></ul></li><li><a href="#g:14">Case Statements
</a></li><li><a href="#g:15">Loops
</a><ul><li><a href="#g:16">Context
</a></li></ul></li><li><a href="#g:17">Debugging
</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>A (mostly logicless) textual templating language in the same
 vein as <a href="https://github.com/Shopify/liquid">Liquid</a> or <a href="http://jinja.pocoo.org/docs/">Jinja2</a>.
</p><p>(ED-E is a character from Fallout New Vegas, pronounced i&#720;-di&#720;-i&#720;, or Eddie.)
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span>  <a href="#t:Template">Template</a> </li><li class="src short"><a href="#v:parse">parse</a> :: Text -&gt; <a href="Text-EDE.html#t:Result">Result</a> <a href="Text-EDE.html#t:Template">Template</a></li><li class="src short"><a href="#v:render">render</a> :: Object -&gt; <a href="Text-EDE.html#t:Template">Template</a> -&gt; <a href="Text-EDE.html#t:Result">Result</a> Builder</li><li class="src short"><a href="#v:eitherParse">eitherParse</a> :: Text -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Either.html#t:Either">Either</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a> <a href="Text-EDE.html#t:Template">Template</a></li><li class="src short"><a href="#v:eitherRender">eitherRender</a> :: Object -&gt; <a href="Text-EDE.html#t:Template">Template</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Either.html#t:Either">Either</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a> Builder</li><li class="src short"><span class="keyword">data</span>  <a href="#t:Meta">Meta</a>  = <a href="#v:Meta">Meta</a> {<ul class="subs"><li><a href="#v:_source">_source</a> :: !<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a></li><li><a href="#v:_row">_row</a> :: !<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Int.html#t:Int">Int</a></li><li><a href="#v:_column">_column</a> :: !<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Int.html#t:Int">Int</a></li></ul>}</li><li class="src short"><span class="keyword">data</span>  <a href="#t:Result">Result</a> a<ul class="subs"><li>= <a href="#v:Error">Error</a> <a href="Text-EDE.html#t:Meta">Meta</a> [<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a>]  </li><li>| <a href="#v:Success">Success</a> a  </li></ul></li><li class="src short"><a href="#v:eitherResult">eitherResult</a> ::  <a href="Text-EDE.html#t:Result">Result</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Either.html#t:Either">Either</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a> a</li><li class="src short"><a href="#v:result">result</a> ::  (<a href="Text-EDE.html#t:Meta">Meta</a> -&gt; [<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a>] -&gt; b) -&gt; (a -&gt; b) -&gt; <a href="Text-EDE.html#t:Result">Result</a> a -&gt; b</li><li class="src short"><a href="#v:fromPairs">fromPairs</a> :: [Pair] -&gt; Object</li><li class="src short"><a href="#v:.-61-">(.=)</a> :: ToJSON a =&gt; Text -&gt; a -&gt; Pair</li><li class="src short"><a href="#v:toLazyText">toLazyText</a> :: Builder -&gt; Text</li></ul></div><div id="interface"><h1 id="g:1">How to use this library
</h1><div class="doc"><p>A simple example of parsing and rendering <code>Text</code> containing a basic conditional
 expression and variable interpolation follows.
</p><p>First the <code><a href="Text-EDE.html#t:Template">Template</a></code> is defined:
</p><pre> &gt;&gt;&gt; let tmpl = parse &quot;{% if var %}Hello, {{ var }}!{% else %}negative!{% endif %}&quot; :: Result Template
</pre><p>Then an <code>Object</code> is defined containing the environment which will be
 available to the <code><a href="Text-EDE.html#t:Template">Template</a></code> during rendering:
</p><pre> &gt;&gt;&gt; let env = render $ fromPairs [ &quot;var&quot; .= &quot;World&quot; ] :: Template -&gt; Result Builder
</pre><p>Finally the environment is applied to the <code><a href="Text-EDE.html#t:Template">Template</a></code>:
</p><pre> &gt;&gt;&gt; tmpl &gt;&gt;= env :: Result Builder
 Success &quot;Hello, World!&quot;
</pre><p>In this manner, <code><a href="Text-EDE.html#t:Template">Template</a></code>s can be pre-compiled to the internal AST and
 the cost of parsing can be amortised if the same <code><a href="Text-EDE.html#t:Template">Template</a></code> is rendered multiple times.
</p></div><h1 id="g:2">Parsing and rendering
</h1><div class="doc"><p>Parsing and rendering require two separate steps intentionally so that the
 more expensive result of parsing can be embedded, and/or reused.
</p><ul><li> Parsing tokenises the input and converts it to an internal AST representation,
 which can be cached for future use.
</li><li> Rendering takes an <code>Object</code> as the environment and a parsed <code><a href="Text-EDE.html#t:Template">Template</a></code>
 to subsitute the values into.
</li></ul></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Template" class="def">Template</a>  </p><div class="doc"><p>A valid parsed and compiled template.
</p></div><div class="subs instances"><p id="control.i:Template" class="caption collapser" onclick="toggleSection('i:Template')">Instances</p><div id="section.i:Template" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Text-EDE.html#t:Template">Template</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> <a href="Text-EDE.html#t:Template">Template</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:parse" class="def">parse</a> :: Text -&gt; <a href="Text-EDE.html#t:Result">Result</a> <a href="Text-EDE.html#t:Template">Template</a></p><div class="doc"><p>Parse <code>Text</code> into a compiled template.
</p></div></div><div class="top"><p class="src"><a name="v:render" class="def">render</a> :: Object -&gt; <a href="Text-EDE.html#t:Template">Template</a> -&gt; <a href="Text-EDE.html#t:Result">Result</a> Builder</p><div class="doc"><p>Render an <code>Object</code> using the supplied <code><a href="Text-EDE.html#t:Template">Template</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:eitherParse" class="def">eitherParse</a> :: Text -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Either.html#t:Either">Either</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a> <a href="Text-EDE.html#t:Template">Template</a></p><div class="doc"><p>Parse <code>Text</code> into a compiled template,
 and convert the <code><a href="Text-EDE.html#t:Result">Result</a></code> using <code><a href="Text-EDE.html#v:eitherResult">eitherResult</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:eitherRender" class="def">eitherRender</a> :: Object -&gt; <a href="Text-EDE.html#t:Template">Template</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Either.html#t:Either">Either</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a> Builder</p><div class="doc"><p>Render an <code>Object</code> using the supplied <code><a href="Text-EDE.html#t:Template">Template</a></code>,
 and convert the <code><a href="Text-EDE.html#t:Result">Result</a></code> using <code><a href="Text-EDE.html#v:eitherResult">eitherResult</a></code>.
</p></div></div><h1 id="g:3">Results and errors
</h1><div class="doc"><p>Unsuccessful <code><a href="Text-EDE.html#v:parse">parse</a></code> or <code><a href="Text-EDE.html#v:render">render</a></code> steps can be inspected or analysed using
 <code><a href="Text-EDE.html#v:result">result</a></code>.
</p><pre> &gt;&gt;&gt; result failure success $ parse tmpl &gt;&gt;= render env
</pre><p>If you're only interested in dealing with errors as strings, and the positional
 information contained in <code><a href="Text-EDE.html#t:Meta">Meta</a></code> is not of use you can use the convenience functions
 <code><a href="Text-EDE.html#v:eitherParse">eitherParse</a></code>, <code><a href="Text-EDE.html#v:eitherRender">eitherRender</a></code>, or convert a <code><a href="Text-EDE.html#t:Result">Result</a></code> to <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Either.html#t:Either">Either</a></code> using <code><a href="Text-EDE.html#v:eitherResult">eitherResult</a></code>.
</p><pre> &gt;&gt;&gt; either failure success $ eitherParse tmpl &gt;&gt;= eitherRender env
</pre></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Meta" class="def">Meta</a>  </p><div class="doc"><p>Meta information describing the source position of an expression or error.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Meta" class="def">Meta</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:_source" class="def">_source</a> :: !<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:_row" class="def">_row</a> :: !<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Int.html#t:Int">Int</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:_column" class="def">_column</a> :: !<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Int.html#t:Int">Int</a></dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:Meta" class="caption collapser" onclick="toggleSection('i:Meta')">Instances</p><div id="section.i:Meta" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Text-EDE.html#t:Meta">Meta</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> <a href="Text-EDE.html#t:Meta">Meta</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> <a href="Text-EDE.html#t:Meta">Meta</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Result" class="def">Result</a> a </p><div class="doc"><p>The result of running parsing or rendering steps.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Error" class="def">Error</a> <a href="Text-EDE.html#t:Meta">Meta</a> [<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a>]</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Success" class="def">Success</a> a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Result" class="caption collapser" onclick="toggleSection('i:Result')">Instances</p><div id="section.i:Result" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Monad">Monad</a> <a href="Text-EDE.html#t:Result">Result</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Control-Monad.html#t:Functor">Functor</a> <a href="Text-EDE.html#t:Result">Result</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Eq.html#t:Eq">Eq</a> a =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Eq.html#t:Eq">Eq</a> (<a href="Text-EDE.html#t:Result">Result</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> a =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="Text-EDE.html#t:Result">Result</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> a =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Text-Show.html#t:Show">Show</a> (<a href="Text-EDE.html#t:Result">Result</a> a)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:eitherResult" class="def">eitherResult</a> ::  <a href="Text-EDE.html#t:Result">Result</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Either.html#t:Either">Either</a> <a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a> a</p><div class="doc"><p>Convert a <code><a href="Text-EDE.html#t:Result">Result</a></code> to an <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Either.html#t:Either">Either</a></code> with the <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Either.html#v:Left">Left</a></code> case holding a formatted
 error message, and <code><a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-Either.html#v:Right">Right</a></code> being the successful result over which <code><a href="Text-EDE.html#t:Result">Result</a></code> is paramterised.
</p></div></div><div class="top"><p class="src"><a name="v:result" class="def">result</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Text-EDE.html#t:Meta">Meta</a> -&gt; [<a href="http://hackage.haskell.org/packages/archive/base/4.6.0.1/doc/html/Data-String.html#t:String">String</a>] -&gt; b)</td><td class="doc"><p>Function to apply to the <code><a href="Text-EDE.html#v:Error">Error</a></code> parameters.
</p></td></tr><tr><td class="src">-&gt; (a -&gt; b)</td><td class="doc"><p>Function to apply to the <code><a href="Text-EDE.html#v:Success">Success</a></code> case.
</p></td></tr><tr><td class="src">-&gt; <a href="Text-EDE.html#t:Result">Result</a> a</td><td class="doc"><p>The <code><a href="Text-EDE.html#t:Result">Result</a></code> to map over.
</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Perform a case analysis on a <code><a href="Text-EDE.html#t:Result">Result</a></code>.
</p></div></div><h1 id="g:4">Convenience
</h1><h2 id="g:5">Data.Aeson
</h2><div class="doc"><p><code><a href="Text-EDE.html#v:fromPairs">fromPairs</a></code> is a wrapper around Aeson's <code>object</code> function which safely strips the outer
 <code>Value</code> constructor, providing the correct type signature for input into <code><a href="Text-EDE.html#v:render">render</a></code>.
</p><p>It is used in combination with the re-exported <code><a href="Text-EDE.html#v:.-61-">.=</a></code> as follows:
</p><pre> &gt;&gt;&gt; render (fromPairs [ &quot;foo&quot; .= &quot;value&quot;, &quot;bar&quot; .= 1 ]) :: Template -&gt; Result Builder
</pre></div><div class="top"><p class="src"><a name="v:fromPairs" class="def">fromPairs</a> :: [Pair] -&gt; Object</p><div class="doc"><p>Create an <code>Object</code> from a list of name/value <code>Pair</code>s.
 See <code>Aeson'</code>s documentation for more details.
</p></div></div><div class="top"><p class="src"><a name="v:.-61-" class="def">(.=)</a> :: ToJSON a =&gt; Text -&gt; a -&gt; Pair</p></div><h2 id="g:6">Data.Text.Lazy.Builder
</h2><div class="doc"><p>The successful result of rendering an <code>Object</code> environment and <code><a href="Text-EDE.html#t:Template">Template</a></code> is
 a lazy <code>Builder</code> which can be converted to <code>Text</code> using the re-exported <code><a href="Text-EDE.html#v:toLazyText">toLazyText</a></code>.
</p></div><div class="top"><p class="src"><a name="v:toLazyText" class="def">toLazyText</a> :: Builder -&gt; Text</p></div><h1 id="g:7">Syntax
</h1><h2 id="g:8">Comments
</h2><div class="doc"><p>Comments are ignored by the parser and omitted from the rendered output.
</p><pre> {# singleline comment #}
</pre><pre> {#
    multiline
    comment
 #}
</pre></div><h2 id="g:9">Variables
</h2><div class="doc"><p>Variables are substituted directly for their <code>Buildable</code> representation.
 An error is raised if the varaible being substituted is not a literal type
 (ie. an <code>Array</code> or <code>Object</code>).
</p><pre> {{ var }}
</pre><p>Nested variable access is also supported for variables which resolve to an <code>Object</code>.
 Dot delimiters are used to chain access through multiple nested <code>Object</code>s.
 The right-most accessor must resolve to a <code>Buildable</code> type as with the previous
 non-nested variable access.
</p><pre> {{ nested.var.access }}
</pre></div><h2 id="g:10">Conditionals
</h2><div class="doc empty">&nbsp;</div><h3 id="g:11">Boolean Logic
</h3><div class="doc empty">&nbsp;</div><h3 id="g:12">Relational Logic
</h3><div class="doc empty">&nbsp;</div><h3 id="g:13">Negation
</h3><div class="doc empty">&nbsp;</div><h2 id="g:14">Case Statements
</h2><div class="doc empty">&nbsp;</div><h2 id="g:15">Loops
</h2><div class="doc empty">&nbsp;</div><h3 id="g:16">Context
</h3><div class="doc empty">&nbsp;</div><h2 id="g:17">Debugging
</h2><div class="doc empty">&nbsp;</div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2.1</p></div></body></html>